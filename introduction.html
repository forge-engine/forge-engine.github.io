<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Forge Kernel Documentation</title>
        <link rel="stylesheet" href="assets/css/docs.css">
        <link rel="stylesheet" href="jush.css">
    </head>
    <body>
        <nav id="top-nav" class="tob-bar">
            <div class="sidebar-logo">
                <button class="mobile-menu-button">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor">
                        <path fill-rule="evenodd" d="M3 6.75A.75.75 0 0 1 3.75 6h16.5a.75.75 0 0 1 0 1.5H3.75A.75.75 0 0 1 3 6.75ZM3 12a.75.75 0 0 1 .75-.75h16.5a.75.75 0 0 1 0 1.5H3.75A.75.75 0 0 1 3 12Zm0 5.25a.75.75 0 0 1 .75-.75h16.5a.75.75 0 0 1 0 1.5H3.75a.75.75 0 0 1-.75-.75Z" clip-rule="evenodd"/>
                    </svg>
                </button>
                <a href="/">Forge Kernel</a>
            </div>
            <form id="search-form" class="search-wrapper">
                <input id="search" type="search" value="" placeholder="Search...">
                <button class="btn-search" type="button">Search</button>
            </form>
            <div class="social-icons">
                <a href="https://github.com/forge-engine/forge">
                    <svg style="width: 24px;height: 24px;" fill="currentColor" viewBox="0 0 24 24"><path d="M12 0C5.37 0 0 5.37 0 12c0 5.31 3.435 9.795 8.205 11.385.6.105.825-.255.825-.57 0-.285-.015-1.23-.015-2.235-3.015.555-3.795-.735-4.035-1.41-.135-.345-.72-1.41-1.23-1.695-.42-.225-1.02-.78-.015-.795.945-.015 1.62.87 1.845 1.23 1.08 1.815 2.805 1.305 3.495.99.105-.78.42-1.305.765-1.605-2.67-.3-5.46-1.335-5.46-5.925 0-1.305.465-2.385 1.23-3.225-.12-.3-.54-1.53.12-3.18 0 0 1.005-.315 3.3 1.23.96-.27 1.98-.405 3-.405s2.04.135 3 .405c2.295-1.56 3.3-1.23 3.3-1.23.66 1.65.24 2.88.12 3.18.765.84 1.23 1.905 1.23 3.225 0 4.605-2.805 5.625-5.475 5.925.435.375.81 1.095.81 2.22 0 1.605-.015 2.895-.015 3.3 0 .315.225.69.825.57A12.02 12.02 0 0024 12c0-6.63-5.37-12-12-12z"/></svg>
                </a>
            </div>
        </nav>

        <aside class="sidebar">
            <nav>
                <div class="sidebar-nav-group">
                    <h5 class="sidebar-category">Getting Started</h5>
                    <a href="#introduction" class="sidebar-topic">
                        Introduction
                    </a>
                    <a href="#installation" class="sidebar-topic">
                        Installation
                        <span class="sidebar-topic-toggle">â†’</span>
                    </a>
                    <a href="#directory-structure" class="sidebar-topic ">
                        Directory Structure
                        <span class="sidebar-topic-toggle">â†’</span>
                    </a>
                </div>
                <div class="sidebar-nav-group">
                    <h5 class="sidebar-category">Architecture</h5>
                    <a href="#kernel-structure" class="sidebar-topic">
                        Kernel Structure
                        <span class="sidebar-topic-toggle">â†’</span>
                    </a>
                    <a href="#dependency-injection" class="sidebar-topic">
                        Dependency Injection
                        <span class="sidebar-topic-toggle">â†’</span>
                    </a>
                    <a href="#capability-system" class="sidebar-topic">
                        Capability System
                        <span class="sidebar-topic-toggle">â†’</span>
                    </a>
                    <a href="#configuration" class="sidebar-topic">
                        Configuration
                        <span class="sidebar-topic-toggle">â†’</span>
                    </a>
                </div>
                <div class="sidebar-nav-group">
                    <h5 class="sidebar-category">Core Concepts</h5>
                    <a href="#database" class="sidebar-topic">
                        Database
                        <span class="sidebar-topic-toggle">â†’</span>
                    </a>
                    <a href="#routing" class="sidebar-topic">
                        Routing
                        <span class="sidebar-topic-toggle">â†’</span>
                    </a>
                    <a href="#views" class="sidebar-topic">
                        Views
                        <span class="sidebar-topic-toggle">â†’</span>
                    </a>
                    <a href="#components" class="sidebar-topic">
                        Components
                        <span class="sidebar-topic-toggle">â†’</span>
                    </a>
                    <a href="#cli" class="sidebar-topic">
                        CLI
                        <span class="sidebar-topic-toggle">â†’</span>
                    </a>
                    <a href="#middleware" class="sidebar-topic">
                        Middleware
                        <span class="sidebar-topic-toggle">â†’</span>
                    </a>
                    <a href="#traits" class="sidebar-topic">
                        Traits
                        <span class="sidebar-topic-toggle">â†’</span>
                    </a>
                    <a href="#helpers" class="sidebar-topic">
                        Helpers
                        <span class="sidebar-topic-toggle">â†’</span>
                    </a>
                    <a href="#services" class="sidebar-topic">
                        Services
                        <span class="sidebar-topic-toggle">â†’</span>
                    </a>
                </div>
                <div class="sidebar-nav-group">
                    <h5 class="sidebar-category">Capabilities</h5>
                    <a href="#forge-package-manager" class="sidebar-topic">
                        ForgePackageManager
                        <span class="sidebar-topic-toggle">â†’</span>
                    </a>
                    <a href="#forge-error-handler" class="sidebar-topic">
                        ForgeErrorHandler
                        <span class="sidebar-topic-toggle">â†’</span>
                    </a>
                    <a href="#forge-events" class="sidebar-topic">
                        ForgeEvents
                        <span class="sidebar-topic-toggle">â†’</span>
                    </a>
                    <a href="#forge-logger" class="sidebar-topic">
                        ForgeLogger
                        <span class="sidebar-topic-toggle">â†’</span>
                    </a>
                    <a href="#forge-storage" class="sidebar-topic">
                        ForgeStorage
                        <span class="sidebar-topic-toggle">â†’</span>
                    </a>
                    <a href="#forge-auth" class="sidebar-topic">
                        ForgeAuth
                        <span class="sidebar-topic-toggle">â†’</span>
                    </a>

                </div>
                <div class="sidebar-nav-group">
                    <h5 class="sidebar-category">Engine API Reference</h5>
                    <a href="#core-components" class="sidebar-topic">
                        Core Components
                        <span class="sidebar-topic-toggle">â†’</span>
                    </a>

                </div>

            </nav>
        </aside>


        <main id="content" class="content">
            <section id="introduction">
                <h1>Forge Kernel</h1>
                <h2>introduction</h2>
                <p>Forge is an Application Hosted Kernel with pluggable capabilities. It's a minimal, dependency-free PHP kernel I built to serve my own projects. It's fully open source under the MIT license.</p>

                <p>
                    I didn't create Forge to compete with anything. I created it because I wanted something I could fully understand, control, and evolve at my own pace.
                    I believe kernels should feel like tools, not black boxes â€” simple, readable, and flexible.
                </p>

                <h3>kernel vs framework</h3>
                <p>
                    Think of it like building a house. A framework is like a fully furnished house â€” everything is already there (furniture, appliances, plumbing, electrical). You move in and use what's provided. It works great if you want what's included, but it's hard to change the foundation or remove things you don't need.
                </p>
                <p>
                    A kernel is like a foundation with utilities. You get the foundation, plumbing, electrical, and basic structure. You decide what to build on top. You add only what you need (kitchen, bedrooms, etc.). You control everything that goes in.
                </p>
                <p>
                    Capabilities are like modular additions. Need a kitchen? Add a kitchen capability. Need a garage? Add a garage capability. Don't need a pool? Don't add it. Each addition is optional and pluggable.
                </p>

                <p>
                    Modern frameworks often try to be everything for everyone, which usually means extra layers of abstraction and heavy dependencies.
                    Forge goes in the opposite direction â€” it tries to stay small, focused, and honest about what it is. A kernel, not a framework.
                </p>

                <h3>philosophy</h3>
                <p>
                    This isnâ€™t a product. Thereâ€™s no company behind it. No support SLA. No roadmap you should depend on.
                    Forge exists because I like to understand and own my stack. If others find value in it â€” awesome. If not â€” thatâ€™s cool too.
                </p>

                <p>
                    Iâ€™m not chasing trends or buzzwords. Forge is built incrementally, based on real project needs.
                    If I need something, I build it â€” and if you ever do too, maybe the pieces will already be there for you to use.
                </p>

                <p>
                    You wonâ€™t find magic here. Just PHP, well-structured, and thoughtfully organized.
                </p>

                <h3>this organization contains</h3>
                <ul>
                    <li>Pluggable capabilities system with official and private capability support</li>
                    <li>Flexible application structure supporting various design patterns (MVC, DDD, Clean Architecture)</li>
                    <li>Powerful dependency injection system</li>
                    <li>The Forge Kernel â€” a minimal, dependency-free PHP kernel (DI, routing, bootstrapping, view engine, configuration manager, and core services).</li>
                    <li>Forge Capabilities â€” self-contained, optional capability modules (database, ORM, auth, storage, etc.) that you plug in when needed.</li>
                    <li>Utilities & Installers â€” scripts and helpers for easier setup and tooling.</li>
                </ul>
                <p>
                    <strong>Capabilities, not built-ins.</strong> Database, ORM, authentication, storage â€” these aren't built into the kernel. They're capabilities you plug in via modules when you need them. The kernel stays lean. You stay in control.
                </p>

                <section>
                    <h3>want to build your own thing?</h3>
                    <p>
                        You can fork the entire kernel and capability ecosystem to start your own direction.
                        Check out <a href="https://github.com/forge-engine/forge/blob/main/docs/FORGING-YOUR-OWN.md">FORGING-YOUR-OWN.md</a>
                        in the main repo for notes on how everything is structured and how to get started.
                    </p>

                    <p>
                        I think every developer should, at some point, try building their own kernel â€” not to replace existing tools,
                        but to learn how things actually work under the hood. Forge is my version of that journey.
                    </p>
                </section>
            </section>

            <section id="installation">
                <h2>installation</h2>
                <p>First things first, you'll need PHP 8.2 or newer installed on your machine.</p>

                <p>
                    Forge is designed to be lightweight and quick to spin up. No complex scaffolding. No endless composer dependencies.
                    Just you, your terminal, and a clean starting point to build on.
                </p>

                <p>Ready? Here's the super simple way to get started:</p>

                <ol>
                    <li>Grab the installer and run it:</li>
                </ol>
                <pre><code>bash &lt;(curl -Ls https://raw.githubusercontent.com/forge-engine/installer/main/installer.sh)</code></pre>

                <p>
                    Thatâ€™s it! This little command will do all the heavy lifting for you â€” clone the starter project, set up the folder structure,
                    and give you a working Forge app you can run immediately.
                </p>

                <p>
                    The default starter is intentionally minimal. No unnecessary files, no extra configs.
                    Just the Forge Kernel and a blank canvas for your ideas. Whether you're building a personal site,
                    a CMS, an API, or a full-on app â€” you can take it wherever you need.
                </p>

                <p>
                    If you're curious about different project types or want something pre-wired with capabilities (like authentication or admin panels),
                    check out the other starters listed in the docs or browse the examples directory.
                </p>

                <p>
                    Forge doesnâ€™t assume how you want to work â€” it just tries to stay out of your way.
                    If you like tinkering with your tools and enjoy building things from the ground up, youâ€™ll probably feel right at home.
                </p>

                <p>Happy coding! ðŸ˜Š</p>
            </section>

            <section id="directory-structure">
                <h2>directory structure</h2>
                <p>
                    Forge keeps things simple and predictable. The default project layout gives you a solid foundation, but youâ€™re always free
                    to organize it however you like. Nothing is locked in â€” use what makes sense for your project.
                </p>

                <p>
                    At the root of your Forge app, youâ€™ll find the following:
                </p>

                <ul>
                    <li><strong>app/</strong> â€“ Your application code. This is where your controllers, services, views, and application logic live.</li>
                    <ul>
                        <li><strong>Commands/</strong> â€“ Custom CLI commands for your application.</li>
                        <li><strong>Components/</strong> â€“ PHP components (Ui/ and Wire/ subfolders).</li>
                        <li><strong>Controllers/</strong> â€“ Route handlers. Required if you're using auto-discovery.</li>
                        <li><strong>Database/</strong> â€“ Migrations and seeders for setting up your schema and sample data.</li>
                        <li><strong>Dto/</strong> â€“ Data Transfer Objects.</li>
                        <li><strong>Events/</strong> â€“ Application events.</li>
                        <li><strong>Models/</strong> â€“ Data models (if using ORM capability).</li>
                        <li><strong>resources/</strong> â€“ Views, layouts, assets, components â€” your UI layer.</li>
                        <ul>
                            <li><strong>assets/</strong> â€“ CSS and JavaScript files (css/ and js/ subfolders).</li>
                            <li><strong>components/</strong> â€“ View components (shared/, ui/, wire/ subfolders).</li>
                            <li><strong>views/</strong> â€“ View templates (layouts/ and pages/ subfolders).</li>
                        </ul>
                        <li><strong>Services/</strong> â€“ Classes injected into other parts of your app. Also auto-discovered.</li>
                        <li><strong>tests/</strong> â€“ Put your app tests here. Forge uses a simple `Test.php` runner.</li>
                    </ul>
                    <li><strong>config/</strong> â€“ Central config for your app. Includes:</li>
                    <ul>
                        <li><strong>app.php</strong> â€“ App name, debug, developer mode, logging paths, CORS, etc.</li>
                        <li><strong>middleware.php</strong> â€“ Define global, web, and API middleware.</li>
                        <li><strong>security.php</strong> â€“ Rate limits, circuit breakers, password rules, JWT settings, IP whitelists.</li>
                        <li><strong>source_list.php</strong> â€“ Package manager registry sources and authentication for capability installs.</li>
                    </ul>
                    <li><strong>engine/</strong> â€“ The actual Forge Kernel source code. You can update or replace this independently.</li>
                    <li><strong>modules/</strong> â€“ All your installed capability modules â€” both official and custom.</li>
                    <li><strong>public/</strong> â€“ Your web root. `index.php` and static assets go here.</li>
                    <li><strong>storage/</strong> â€“ Logs, compiled views, uploads, cache, etc.</li>
                    <li><strong>.env</strong>, <strong>env-example</strong> â€“ Your environment settings and template.</li>
                    <li><strong>forge.php</strong> â€“ The Forge CLI for installing modules, clearing caches, generating files, etc.</li>
                    <li><strong>install.php</strong> â€“ Handles framework updates and downgrades. Handy for version control.</li>
                    <li><strong>LICENSE</strong>, <strong>LICENSE-MIT.txt</strong>, <strong>README.md</strong> â€“ Usual open source files.</li>
                </ul>

                <p>
                    The structure is modular on purpose. If you don't need something â€” like services or tests â€” you can just delete those folders.
                    Forge won't complain. You can even skip the whole <code>app/</code> folder if you're building your app entirely using capabilities.
                </p>

                <p>
                    The only requirement: if youâ€™re using the Forge auto-discovery system, controllers must go in <code>Controllers/</code>,
                    services in <code>Services/</code>, and migrations/seeders inside <code>database/</code>. Everything else is flexible.
                </p>

                <p>
                    Think of this structure as a starting point, not a rulebook. Youâ€™re in control.
                </p>
            </section>

            <section id="kernel-structure">
                <h2>kernel structure</h2>
                <p>
                    The Forge Kernel is lightweight but powerful â€” built from the ground up to be understandable, flexible, and easy to extend.
                    If you want to dive into the source code or even fork the kernel and make it your own, this overview will help you get familiar with the layout.
                </p>

                <p>
                    The kernel lives inside the <code>engine/</code> directory and is structured like this:
                </p>

                <ul>
                    <li><strong>CLI/</strong> â€“ Everything related to the Forge command line:</li>
                    <ul>
                        <li><strong>Commands/</strong> â€“ Built-in CLI commands (like installing modules or generating files).</li>
                        <li><strong>Traits/</strong> â€“ Reusable CLI behaviors.</li>
                        <li><strong>Application.php</strong> â€“ Entry point for running CLI commands.</li>
                        <li><strong>Command.php</strong> â€“ Interface that all commands implement.</li>
                    </ul>

                    <li><strong>Core/</strong> â€“ The heart of the Forge Kernel. It's broken down into small, focused parts:</li>
                    <ul>
                        <li><strong>Bootstrap/</strong> â€“ Startup logic and initialization.</li>
                        <li><strong>Config/</strong> â€“ Loads your config files and makes them available throughout the app.</li>
                        <li><strong>DI/</strong> â€“ The dependency injection container (like a smart warehouse manager â€” knows where everything is, gets you what you need).</li>
                        <li><strong>Debug/</strong> â€“ Debug tools like <code>Metrics.php</code>.</li>
                        <li><strong>Dto/</strong> â€“ Support for Data Transfer Objects (used in components and services).</li>
                        <li><strong>Helpers/</strong> â€“ Utility functions and convenience methods.</li>
                        <li><strong>Http/</strong> â€“ Request/response handling, routing, and middleware interfaces.</li>
                        <li><strong>Module/</strong> â€“ Internal logic for capability discovery, loading, and registration.</li>
                        <li><strong>Routing/</strong> â€“ Route matching and auto-discovery.</li>
                        <li><strong>Schema/</strong> â€“ For defining and managing validation schemas and rules.</li>
                        <li><strong>Security/</strong> â€“ Rate limiting, JWT, circuit breakers, and other protections.</li>
                        <li><strong>Services/</strong> â€“ Core Forge services like logging, events, etc.</li>
                        <li><strong>Session/</strong> â€“ Simple session manager.</li>
                        <li><strong>Support/</strong> â€“ Shared utilities and helpers.</li>
                        <li><strong>Templates/</strong> â€“ Scaffold files used when generating new code (controllers, modules, etc.).</li>
                        <li><strong>Validation/</strong> â€“ Input validation system.</li>
                        <li><strong>View/</strong> â€“ View engine, layouts, and rendering logic.</li>
                        <li><strong>Autoloader.php</strong> â€“ Forgeâ€™s internal PSR-4 class loader.</li>
                        <li><strong>Engine.php</strong> â€“ The main engine bootstrapper that glues everything together.</li>
                    </ul>

                    <li><strong>Database/Migrations/</strong> â€“ Kernel-level migrations if the kernel needs to evolve the schema.</li>
                    <li><strong>Exceptions/</strong> â€“ Shared exception types used across the kernel.</li>
                    <li><strong>Templates/Views/</strong> â€“ Default views like <code>error_page.php</code>.</li>
                    <li><strong>Traits/</strong> â€“ Kernel-level traits for shared behavior.</li>
                    <li><strong>tests/</strong> â€“ Unit tests for the Forge Kernel itself.</li>
                    <li><strong>LICENSE</strong>, <strong>README.md</strong> â€“ Usual stuff.</li>
                </ul>

                <p>
                    Everything is built in plain PHP, without any dependencies â€” so you can dig into any part of the kernel
                    and understand exactly what's going on. No magic, no black boxes.
                </p>

                <p>
                    <strong>Note:</strong> Database and ORM are not in the kernel. They're capabilities you install when you need them. The kernel provides the foundation â€” you add what you need on top.
                </p>

                <p>
                    Want to customize or even fork the kernel? Go for it. It's all MIT-licensed and designed to be yours.
                </p>
            </section>

            <section id="dependency-injection">
                <h2>Dependency Injection: My Way of Keeping Things Tidy</h2>
                <p>
                    Okay, so let's talk about something called Dependency Injection (DI). For me, building Forge has been about keeping things simple and understandable, and DI is a big part of that philosophy. Think of it like this: instead of your code having to go out and grab all the tools it needs, I wanted a system where those tools are just handed to it.
                </p>

                <p>
                    It's like when you're building something, right? It's way smoother if you have all your parts laid out and ready instead of constantly searching for them. That's what DI does for your code. It helps keep everything organized and makes it easier to see what relies on what.
                </p>

                <p>
                    In Forge, the <code>Container</code> is like a smart warehouse manager. It knows where everything is stored, gets you what you need when you ask, and manages dependencies automatically. It's the guy in charge of handing out these tools (we call them services). It knows how to create them and keep them ready when they're needed.
                </p>

                <h3>The Simple Breakdown (as I See It)</h3>
                <ul>
                    <li>
                        <strong>Telling Forge About the Tools:</strong> First, we need to tell the
                        <code>Container</code> about the different tools (services) we have and how to make them. Here's how you can do that:
                    </li>
                    <li><strong>Using Attributes (My Preferred Way):</strong>
                        I like to keep things close to where they're used.
                        That's why I added attributes like <code>#[Service]</code>.
                        Just slap that on top of your class, and Forge knows it's something
                        the <code>Container</code> should manage. It's clean and keeps your code organized.
                    </li>
                </ul>
                <pre><code class="jush-php">
                    use Forge\Core\DI\Attributes\Service;

                    #[Service]
                    class MyAwesomeService
                    {
                    public function doSomething() {
                    // ...
                    }
                    }
                </code></pre>

                <p>Using register(): If you need more control, you can use the register() method.
                    This is useful if you want to specify a different ID for the service.</p>
                <pre><code class="jush-php">
                    use Forge\Core\DI\Container;

                    $container = Container::getInstance();
                    $container->register(MyAwesomeService::class); // Registers it with the class name as the ID

                    $container->register('my.awesome.service', MyAwesomeService::class); // Registers it with a custom ID
                </code></pre>

                <p>Binding with bind(): This is handy when you want to map an interface to a specific implementation, or if
                    you want to provide a custom function (a Closure) to create the service.</p>
                <pre><code class="jush-php">
                    use Forge\Core\DI\Container;
                    use App\Interfaces\MyServiceInterface;
                    use App\Services\MyServiceImpl;

                    $container = Container::getInstance();
                    $container->bind(MyServiceInterface::class, MyServiceImpl::class);

                    $container->bind('my.service', function(Container $c) {
                    return new MyServiceImpl($c->get('some.other.service')); // Injecting another service
                    });

                </code></pre>
                <p>Singletons with singleton(): If you only want one instance of a service, use singleton().</p>
                <pre><code class="jush-php">
                    use Forge\Core\DI\Container;

                    $container = Container::getInstance();
                    $container->singleton('my.config', function() {
                    return ['api_key' => 'your_key', 'debug' => true];
                    });
                </code></pre>

                <p>
                    Asking for the Tools: When a piece of your code needs a tool, it just asks the Container.
                    Forge then makes sure it has one ready and passes it over. That's what the get() and make()
                    methods are for.
                </p>

                <p>get() (My Go-To): This is the most common way to get a service. It's simple and efficient.</p>
                <pre><code class="jush-php">
                    use Forge\Core\DI\Container;

                    $container = Container::getInstance();
                    $service = $container->get(MyAwesomeService::class);
                    $service->doSomething();
                </code></pre>
                <p></p>make(): This is similar to get(), but it always creates a new instance of the service,
                even if it's registered as a singleton. I don't use this as often, but it's there if you need it.</p>
                <pre><code class="jush-php">
                    use Forge\Core\DI\Container;

                    $container = Container::getInstance();
                    $service1 = $container->make(MyAwesomeService::class);
                    $service2 = $container->make(MyAwesomeService::class); // $service1 and $service2 are different instances
                </code></pre>



                <p>
                    Forge Being Helpful (Auto-wiring): This is one of the cooler parts. Often, when your code asks for a tool,
                    Forge can automatically figure out what other tools that tool needs to work! It looks at the constructor
                    (that __construct() thing in your PHP classes) and sees what else is being requested.
                    If Forge knows how to make those other things, it just does it â€“ that's auto-wiring.
                </p>
                <p>
                    Making Sure There's Only One (Singletons): For some tools, you only ever need one in your whole project â€“
                    like a settings manager. The singleton() method makes sure that Forge only creates one of those tools and
                    gives you the same one every time you ask for it.
                </p>
                <p>
                    Using Attributes for Easy Setup: You might see things like #[Service] in the code. This is just a handy
                    way to tell Forge, "Hey, this class is a service, so manage it for me!" It's like putting a label on a
                    tool so the Container knows what it is without you having to spell it out somewhere else.
                </p>


                <h3>Why Go Through All This?</h3>
                <p>
                    For me, using dependency injection just makes sense. It leads to code that's:
                </p>
                <ul>
                    <li><strong>Easier to Grasp:</strong> You can see more clearly what each piece of code needs to do its job.</li>
                    <li><strong>Simpler to Test:</strong> When you're testing, you can easily swap out the real tools with fake ones to make sure your code is working correctly in isolation.</li>
                    <li><strong>More Flexible Down the Road:</strong> If you decide to change how a tool works under the hood, you often don't have to change the code that uses it.</li>
                    <li><strong>More Reusable in Different Places:</strong> Pieces of your code become less tied to specific ways of doing things, making them easier to use in different parts of your project.</li>
                </ul>

                <h3>Usage Examples (Show Me the Code!)</h3>
                <p>
                    Let's look at some real-world examples from Forge to see DI in action:
                </p>

                <h4>Example 1: Injecting a Service into a Controller</h4>
                <p>
                    Here's how I inject the <code>ForgeAuthService</code> into a controller. The controller needs this service to handle user authentication. Because of DI, the controller doesn't have to worry about *how* to create the <code>ForgeAuthService</code>; it just gets it handed over.
                </p>
                <pre><code class="jush-php">
                    use Forge\Core\DI\Attributes\Service;

                    #[Service]
                    class MyAwesomeService
                    {
                    public function doSomething() {
                    // ...
                    }
                    }
                </code></pre>
                <pre><code class="jush-php">
                    declare(strict_types=1);

                    namespace App\Controllers;

                    use App\Modules\ForgeAuth\Services\ForgeAuthService;
                    use Forge\Core\DI\Attributes\Service;
                    use Forge\Core\Http\Attributes\Middleware;
                    use Forge\Core\Http\Response;
                    use Forge\Core\Routing\Route;
                    use Forge\Traits\ControllerHelper;
                    use Forge\Traits\SecurityHelper;

                    #[Service] // Hey Forge, manage this controller!
                    #[Middleware('web')]
                    final class DashboardController
                    {
                    use ControllerHelper;
                    use SecurityHelper;

                    public function __construct(private ForgeAuthService $forgeAuthService) // Inject the auth service
                    {
                    }

                    #[Route("/dashboard")]
                    #[Middleware('App\Modules\ForgeAuth\Middlewares\AuthMiddleware')]
                    public function welcome(): Response
                    {
                    $user = $this->forgeAuthService->user() ?? [];

                    $data = [
                    "title" => "Welcome to Forge Kernel",
                    "user" => $user
                    ];

                    return $this->view(view: "pages/dashboard/index", data: $data);
                    }

                    }
                </code></pre>

                <p>Notice how the ForgeAuthService is declared in the constructor? Forge's Container automatically
                    provides an instance of that service when the DashboardController is created. Clean and simple!</p>


                <h4>Example 2: Using DI in an Event Listener</h4>
                <p>
                    This example shows how a service (<code>PageVisitLogger</code>) is used to handle an event.
                    The event listener class is itself a service, thanks to the <code>#[Service]</code> attribute.
                </p>
                <pre><code class="jush-php">

                    declare(strict_types=1);

                    namespace App\Services;

                    use App\Events\TestPageVisitedEvent;
                    use App\Modules\ForgeEvents\Attributes\EventListener;
                    use Forge\Core\DI\Attributes\Service;

                    #[Service]
                    class PageVisitLogger
                    {
                    #[EventListener(TestPageVisitedEvent::class)]
                    public function handlePageVisit(TestPageVisitedEvent $event): void
                    {
                    // Implement your logging logic here
                    $logEntry = sprintf(
                    "User %d visited test page at %s",
                    $event->userId,
                    $event->visitedAt
                    );

                    // Example: Write to log file
                    file_put_contents(
                    BASE_PATH . '/storage/logs/page_visits.log',
                    $logEntry . PHP_EOL,
                    FILE_APPEND
                    );
                    }

                    }
                </code></pre>


                <p>In this case, if the PageVisitLogger had any dependencies, they would also be injected by the Container.</p>


                <h3>A Bit More on Using DI in Forge</h3>
                <p>
                    Here are a few more things to keep in mind when working with DI in Forge:
                </p>
                <ul>
                    <li>
                        <strong>Embrace Interfaces:</strong> I encourage you to use interfaces whenever possible. This makes your code even more flexible. For example, if you have a service that sends emails, define an <code>EmailServiceInterface</code> and then create different classes that implement that interface (e.g., <code>SmtpEmailService</code>, <code>MailgunEmailService</code>). Then, you can use <code>bind()</code> to tell Forge which implementation to use. This way, you can easily swap out email providers without changing the code that sends emails.
                    </li>
                    <li>
                        <strong>Keep it Lean:</strong>
                        DI is a powerful tool, but don't overuse it. Only inject things that your class truly *depends* on. If a class can create an object itself without becoming too complex, it's often fine to do so.
                    </li>
                    <li>
                </ul>
                <strong>Configuration:</strong>
                <p>Sometimes, services need configuration values (like API keys, database settings, etc.).
                    You can use the <code>setParameter()</code> and <code>getParameter()</code> methods of the <code>Container</code> to manage these.</p>
                <pre><code class="jush-php">
                    use Forge\Core\DI\Container;

                    $container = Container::getInstance();
                    $container->set('api.key', 'your_super_secret_key');

                    // ...

                    class MyService {
                    public function __construct(private string $apiKey) {} // Inject the parameter

                    public function doSomething() {
                    // Use $this->apiKey
                    }

                    }
                    $container->bind(MyService::class, function(Container $c) {
                    return new MyService($c->get('api.key'));
                    });
                </code></pre>

                <p>Tags: Forge also supports "tags". This lets you group related services together.
                    For example, you might tag all your event listeners with an "event.listener" tag.
                    Then, you can easily retrieve all of them from the Container.
                </p>
                <pre><code class="jush-php">
                    use Forge\Core\DI\Container;
                    use Forge\Core\DI\Attributes\Service;
                    use Forge\Core\DI\Attributes\Tag;

                    #[Service]
                    #[Tag('event.listener')]
                    class MyEventListener {}

                    #[Service]
                    #[Tag('event.listener')]
                    class AnotherEventListener {}

                    // ...

                    $container = Container::getInstance();
                    $listeners = $container->tagged('event.listener'); // Get all services with the tag
                </code></pre>

                <p>
                    Ultimately, Forge's dependency injection is about keeping things clean, manageable, and flexible
                    â€“ the way I like to build. It's there to help you, the builder, focus on the actual
                    logic of your project without getting bogged down in the details of creating and managing dependencies.
                </p>
            </section>

            <section id="capability-system">
                <h2>Capability System</h2>
                <p>
                    Forge uses a capability system. Capabilities are optional, pluggable modules that extend the kernel's functionality.
                </p>
                <p>
                    Think of capabilities like modular additions to a house. The kernel gives you the foundation. Capabilities add what you need: database, ORM, authentication, storage, testing â€” all optional, all pluggable.
                </p>
                <p>
                    Need a database? Install a database capability. Need an ORM? Install an ORM capability. Don't need authentication? Don't install it. The kernel stays lean. You stay in control.
                </p>
                <p>
                    See the <a href="modules.html">Capabilities</a> section for more details on installing and managing capabilities.
                </p>
            </section>

            <section id="configuration">
                <h2>Configuration</h2>
                <p>Work in progress..</p>
            </section>

            <section id="database">
                <h2>Database</h2>
                <p>
                    Database functionality is not built into the kernel. It's a capability you install when you need it.
                </p>
                <p>
                    Install a database capability like <code>forge-database-sql</code> or <code>forge-sql-orm</code> to add database functionality to your application.
                </p>
                <p>
                    See the <a href="modules.html">Capabilities</a> section for available database capabilities.
                </p>
            </section>

            <section id="routing">
                <h2>Routing</h2>
                <p>Work in progress..</p>
            </section>

            <section id="views">
                <h2>Views</h2>
                <p>Work in progress..</p>
            </section>

            <section id="components">
                <h2>Components</h2>
                <p>Work in progress..</p>
            </section>

            <section id="cli">
                <h2>CLI</h2>
                <p>Work in progress..</p>
            </section>

            <section id="middleware">
                <h2>Middleware</h2>
                <p>Work in progress..</p>
            </section>

            <section id="traits">
                <h2>Traits</h2>
                <p>Work in progress..</p>
            </section>

            <section id="helpers">
                <h2>Helpers</h2>
                <p>Work in progress..</p>
            </section>

            <section id="services">
                <h2>Services</h2>
                <p>Work in progress..</p>
            </section>

            <section id="forge-package-manager">
                <h2>Forge Package Manager</h2>
                <p>Work in progress..</p>
            </section>

            <section id="forge-error-handler">
                <h2>Forge Error Handler</h2>
                <p>Work in progress..</p>
            </section>

            <section id="forge-events">
                <h2>Forge Events</h2>
                <p>Work in progress..</p>
            </section>

            <section id="forge-logger">
                <h2>Forge Logger</h2>
                <p>Work in progress..</p>
            </section>

            <section id="forge-storage">
                <h2>Forge Storage</h2>
                <p>Work in progress..</p>
            </section>

            <section id="forge-auth">
                <h2>Forge Auth</h2>
                <p>Work in progress..</p>
            </section>

            <section id="core-components">
                <h2>Core Components</h2>
                <p>Work in progress..</p>
            </section>

        </main>
        <script src="./assets/js/script.js"></script>
        <script src="./assets/js/syntax.js"></script>
        <script type="text/javascript">
            jush.style('jush.css');
            jush.highlight_tag('code');
        </script>
    </body>
</html>