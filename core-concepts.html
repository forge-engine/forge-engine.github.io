<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Core Concepts - Forge Kernel Documentation</title>
    <link rel="stylesheet" href="assets/css/forge-docs.css">
</head>
<body>
    <div class="docs-container">
        <aside class="sidebar">
            <nav>
                <ul class="sidebar-nav">
                    <li class="sidebar-nav-group">
                        <div class="sidebar-nav-group-title">Navigation</div>
                        <ul class="sidebar-nav" style="list-style: none; padding-left: 0;">
                            <li class="sidebar-nav-item">
                                <a href="index.html" class="sidebar-nav-link">Home</a>
                            </li>
                            <li class="sidebar-nav-item">
                                <a href="introduction.html" class="sidebar-nav-link">Introduction</a>
                            </li>
                            <li class="sidebar-nav-item">
                                <a href="getting-started.html" class="sidebar-nav-link">Getting Started</a>
                            </li>
                            <li class="sidebar-nav-item">
                                <a href="core-concepts.html" class="sidebar-nav-link active">Core Concepts</a>
                            </li>
                            <li class="sidebar-nav-item">
                                <a href="modules.html" class="sidebar-nav-link">Capabilities</a>
                            </li>
                            <li class="sidebar-nav-item">
                                <a href="api-reference.html" class="sidebar-nav-link">API Reference</a>
                            </li>
                        </ul>
                    </li>
                    <li class="sidebar-nav-group">
                        <div class="sidebar-nav-group-title">On This Page</div>
                        <ul class="sidebar-nav" style="list-style: none; padding-left: 0;">
                            <li class="sidebar-nav-item">
                                <a href="#architecture" class="sidebar-nav-link">Architecture</a>
                            </li>
                            <li class="sidebar-nav-item">
                                <a href="#dependency-injection" class="sidebar-nav-link">Dependency Injection</a>
                            </li>
                            <li class="sidebar-nav-item">
                                <a href="#routing-system" class="sidebar-nav-link">Routing System</a>
                            </li>
                            <li class="sidebar-nav-item">
                                <a href="#middleware" class="sidebar-nav-link">Middleware</a>
                            </li>
                            <li class="sidebar-nav-item">
                                <a href="#view-engine" class="sidebar-nav-link">View Engine</a>
                            </li>
                            <li class="sidebar-nav-item">
                                <a href="#database-orm" class="sidebar-nav-link">Database & ORM</a>
                            </li>
                            <li class="sidebar-nav-item">
                                <a href="#capability-system" class="sidebar-nav-link">Capability System</a>
                            </li>
                            <li class="sidebar-nav-item">
                                <a href="#configuration" class="sidebar-nav-link">Configuration</a>
                            </li>
                            <li class="sidebar-nav-item">
                                <a href="#async-processing" class="sidebar-nav-link">Async Processing</a>
                            </li>
                            <li class="sidebar-nav-item">
                                <a href="#cli-kernel" class="sidebar-nav-link">CLI Kernel</a>
                            </li>
                        </ul>
                    </li>
                </ul>
            </nav>
        </aside>

        <button class="mobile-menu-toggle" aria-label="Toggle menu">☰</button>
        <div class="mobile-overlay"></div>

        <main class="main-content">
            <article>
                <header class="docs-header">
                    <h1>Core Concepts</h1>
                    <p>How Forge Kernel works under the hood.</p>
                </header>

                <section id="architecture">
                    <h2>Architecture</h2>
                    <p>
                        Forge Kernel uses a modular architecture with dependency injection. It's built to be simple and flexible. Think of it like a foundation with utilities — you get the foundation, plumbing, electrical, and basic structure. You decide what to build on top.
                    </p>

                    <h3>Kernel Components (Built-in)</h3>
                    <ul>
                        <li>Kernel Core</li>
                        <li>Router</li>
                        <li>View Engine</li>
                        <li>DI Container</li>
                        <li>Capability Loader</li>
                        <li>CLI Kernel</li>
                        <li>Bootstrap</li>
                        <li>Config Manager</li>
                    </ul>

                    <h3>Capabilities (Pluggable)</h3>
                    <p>
                        These are <strong>not</strong> built into the kernel. Install them as capabilities when needed:
                    </p>
                    <ul>
                        <li>Database (ForgeDatabaseSQL)</li>
                        <li>ORM (ForgeSqlOrm)</li>
                        <li>Authentication (ForgeAuth)</li>
                        <li>Storage (ForgeStorage)</li>
                        <li>And more...</li>
                    </ul>
                </section>

                <section id="dependency-injection">
                    <h2>Dependency Injection</h2>
                    <p>
                        Forge's DI container is like a smart warehouse manager. It knows where everything is stored, gets you what you need when you ask, and manages dependencies automatically. It resolves dependencies using PHP attributes, keeping code testable and clean.
                    </p>

                    <h3>Service Registration</h3>
                    <div class="code-block">
                        <pre><code>&lt;?php

use Forge\Core\DI\Attributes\Service;

#[Service]
class UserService
{
    public function __construct(
        private UserRepository $repository,
        private EmailService $emailService
    ) {}
    
    public function createUser(array $data): User
    {
        $user = $this->repository->create($data);
        $this->emailService->sendWelcomeEmail($user);
        return $user;
    }
}

#[Service(singleton: true)] // Only one instance throughout the application
class CacheService
{
    private array $cache = [];
    
    public function get(string $key): mixed
    {
        return $this->cache[$key] ?? null;
    }
}</code></pre>
                    </div>

                    <h3>Interface Binding</h3>
                    <div class="code-block">
                        <pre><code>&lt;?php

use Forge\Core\DI\Attributes\Bind;

interface PaymentGatewayInterface
{
    public function charge(float $amount): bool;
}

#[Service]
#[Bind(PaymentGatewayInterface::class)]
class StripePaymentGateway implements PaymentGatewayInterface
{
    public function charge(float $amount): bool
    {
        // Stripe implementation
        return true;
    }
}</code></pre>
                    </div>
                </section>

                <section id="routing-system">
                    <h2>Routing System</h2>
                    <p>
                        Attribute-based routing that auto-discovers routes from controllers. No separate route files needed.
                    </p>

                    <div class="code-block">
                        <pre><code>&lt;?php

use Forge\Core\Routing\Route;
use Forge\Core\Http\Request;
use Forge\Core\Http\Response;

class ApiController
{
    #[Route("/api/users")]
    public function listUsers(): Response
    {
        return $this->json(User::query()->get());
    }
    
    #[Route("/api/users/{id}", method: "GET")]
    public function getUser(Request $request, int $id): Response
    {
        $user = User::query()->id($id)->first();
        return $this->json($user);
    }
    
    #[Route("/api/users", method: "POST")]
    public function createUser(Request $request): Response
    {
        $data = $request->json();
        $user = User::create($data);
        return $this->json($user, 201);
    }
    
    #[Route("/api/users/{id}", method: "PUT")]
    public function updateUser(Request $request, int $id): Response
    {
        $user = User::query()->id($id)->first();
        $user->update($request->json());
        return $this->json($user);
    }
}</code></pre>
                    </div>

                    <p>
                        <strong>Note:</strong> Use curly braces for route parameters. Names must match method params.
                    </p>
                </section>

                <section id="middleware">
                    <h2>Middleware</h2>
                    <p>
                        Filter HTTP requests before they hit your application.
                    </p>

                    <h3>Creating Middleware</h3>
                    <div class="code-block">
                        <pre><code>&lt;?php

use Forge\Core\Http\Middleware;
use Forge\Core\Http\Request;
use Forge\Core\Http\Response;

class AuthMiddleware extends Middleware
{
    public function handle(Request $request, callable $next): Response
    {
        if (!$request->hasHeader('Authorization')) {
            return new Response('Unauthorized', 401);
        }
        
        // Continue to next middleware or controller
        return $next($request);
    }
}</code></pre>
                    </div>

                    <h3>Applying Middleware</h3>
                    <div class="code-block">
                        <pre><code>&lt;?php

use Forge\Core\Http\Attributes\Middleware;

// Apply middleware to entire controller
#[Middleware("auth")]
class DashboardController
{
    #[Route("/dashboard")]
    public function index(): Response
    {
        return $this->view('dashboard/index');
    }
    
    #[Route("/dashboard/settings")]
    public function settings(): Response
    {
        return $this->view('dashboard/settings');
    }
}

// Apply middleware to specific methods
class UserController
{
    #[Middleware("App\Modules\ForgeAuth\Middlewares\AuthMiddleware")]
    #[Route("/profile")]
    public function profile(): Response
    {
        return $this->view('user/profile');
    }
    
    // Multiple middleware using repeatable attribute
    #[Middleware("web")]
    #[Middleware("auth")]
    #[Route("/admin")]
    public function admin(): Response
    {
        return $this->view('admin/dashboard');
    }
}</code></pre>
                    </div>

                    <p>
                        Use <code>#[Middleware]</code> for controllers/methods, or <code>middlewares</code> in <code>#[Route]</code> for routes.
                    </p>
                </section>

                <section id="view-engine">
                    <h2>View Engine</h2>
                    <p>
                        PHP-first templating. No new syntax to learn.
                    </p>

                    <h3>Template Inheritance</h3>
                    <div class="code-block">
                        <pre><code>&lt;!-- layouts/app.php --&gt;
&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;title&gt;&lt;?= $title ?? 'My App' ?&gt;&lt;/title&gt;
    &lt;?php use Forge\Core\View\View; echo View::section('head'); ?&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;header&gt;
        &lt;?php use Forge\Core\View\View; echo View::section('header'); ?&gt;
    &lt;/header&gt;
    
    &lt;main&gt;
        &lt;?php use Forge\Core\View\View; echo View::section('content'); ?&gt;
    &lt;/main&gt;
    
    &lt;footer&gt;
        &lt;?php use Forge\Core\View\View; echo View::section('footer'); ?&gt;
    &lt;/footer&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
                    </div>

                    <h3>Child Templates</h3>
                    <div class="code-block">
                        <pre><code>&lt;!-- pages/home.php --&gt;
&lt;?php use Forge\Core\View\View; View::layout(name: "layouts/app", loadFromModule: false); ?&gt;

&lt;?php View::startSection('head'); ?&gt;
    &lt;link rel="stylesheet" href="/css/home.css"&gt;
&lt;?php View::endSection(); ?&gt;

&lt;?php View::startSection('content'); ?&gt;
    &lt;div class="hero"&gt;
        &lt;h1&gt;Welcome to &lt;?= $appName ?&gt;&lt;/h1&gt;
        &lt;p&gt;&lt;?= $description ?&gt;&lt;/p&gt;
    &lt;/div&gt;
&lt;?php View::endSection(); ?&gt;</code></pre>
                    </div>
                </section>

                <section id="database-orm">
                    <h2>Database & ORM (Capabilities)</h2>
                    <p>
                        Database and ORM are <strong>not built into the kernel</strong>. They're capabilities you install when you need them. Install a database capability like <code>ForgeDatabaseSQL</code> or an ORM capability like <code>ForgeSqlOrm</code>.
                    </p>
                    <p>
                        <strong>Note:</strong> The examples below assume you've installed a database/ORM capability. The kernel itself doesn't include these features.
                    </p>

                    <h3>Model Definition</h3>
                    <div class="code-block">
                        <pre><code>&lt;?php

use App\Modules\ForgeSqlOrm\ORM\Model;
use App\Modules\ForgeSqlOrm\ORM\Attributes\Table;
use App\Modules\ForgeSqlOrm\ORM\Attributes\Column;
use App\Modules\ForgeSqlOrm\ORM\Attributes\Hidden;
use App\Modules\ForgeSqlOrm\ORM\Attributes\ProtectedFields;
use App\Modules\ForgeSqlOrm\ORM\Values\Cast;
use App\Modules\ForgeSqlOrm\ORM\Values\Relate;
use App\Modules\ForgeSqlOrm\ORM\Values\RelationKind;

#[Table('users')]
#[ProtectedFields('password', 'remember_token')]
class User extends Model
{
    #[Column(primary: true, cast: Cast::INTEGER)]
    public int $id;
    
    #[Column(cast: Cast::STRING)]
    public string $name;
    
    #[Column(cast: Cast::STRING)]
    public string $email;
    
    #[Column(cast: Cast::STRING)]
    #[Hidden]
    public string $password;
    
    // Relationships use #[Relate] attribute
    #[Relate(
        kind: RelationKind::HasMany,
        target: Post::class,
        foreignKey: 'user_id',
        localKey: 'id'
    )]
    public function posts()
    {
        return $this->relation('posts');
    }
}</code></pre>
                    </div>

                    <h3>Query Builder</h3>
                    <div class="code-block">
                        <pre><code>&lt;?php

// Get all records
$users = User::query()->get();

// Find by ID
$user = User::query()->id(1)->first();

// Where queries
$activeUsers = User::query()
    ->where('status', '=', 'active')
    ->get();

// Advanced queries
$users = User::query()
    ->where('created_at', '>', '2024-01-01')
    ->get();

// With relationships
$user = User::query()
    ->with('posts')
    ->id(1)
    ->first();

// Access relationship
$posts = $user->load('posts');</code></pre>
                    </div>
                    <p>
                        <strong>Note:</strong> Forge uses a query builder pattern. Always start with <code>Model::query()</code> to build queries. There are no static methods like <code>all()</code> or <code>find()</code> directly on the Model class.
                    </p>
                </section>

                <section id="capability-system">
                    <h2>Capability System</h2>
                    <p>
                        Extend Forge Kernel with self-contained capability modules. Think of capabilities like modular additions to a house. The kernel gives you the foundation. Capabilities add what you need: database, ORM, authentication, storage — all optional, all pluggable.
                    </p>
                    <p>
                        Need a database? Install a database capability. Need an ORM? Install an ORM capability. Don't need authentication? Don't install it. The kernel stays lean. You stay in control.
                    </p>

                    <h3>Capability Structure</h3>
                    <div class="code-block">
                        <pre><code>{
  "$schema": "./../../engine/Core/Schema/module-schema.json",
  "name": "forge-my-module",
  "version": "1.0.0",
  "description": "A custom module for my application",
  "type": "generic",
  "order": 100,
  "author": "Your Name",
  "license": "MIT"
}</code></pre>
                    </div>

                    <h3>Capability Class</h3>
                    <div class="code-block">
                        <pre><code>&lt;?php

namespace App\Modules\MyModule;

use Forge\Core\DI\Container;
use Forge\Core\Module\Attributes\Compatibility;
use Forge\Core\Module\Attributes\Module;
use Forge\Core\Module\Attributes\Repository;
use Forge\Core\DI\Attributes\Service;
use Forge\Core\Module\Attributes\LifecycleHook;
use Forge\Core\Module\LifecycleHookName;
use App\Modules\MyModule\Contracts\MyModuleInterface;
use App\Modules\MyModule\Services\MyModuleService;

#[Module(
    name: 'MyModule',
    description: 'A custom module for my application',
    order: 100
)]
#[Service]
#[Compatibility(kernel: '>=0.1.0', php: '>=8.3')]
#[Repository(type: 'git', url: 'https://github.com/your-repo/modules')]
final class MyModule
{
    public function register(Container $container): void
    {
        // Register services
        $container->bind(MyModuleInterface::class, MyModuleService::class);
    }

    #[LifecycleHook(hook: LifecycleHookName::AFTER_MODULE_REGISTER)]
    public function onAfterModuleRegister(): void
    {
        // Boot logic after module registration
    }
}</code></pre>
                    </div>
                </section>

                <section id="configuration">
                    <h2>Configuration Management</h2>
                    <p>
                        Environment-based configuration that's secure and flexible.
                    </p>

                    <div class="code-block">
                        <pre><code>&lt;?php

use Forge\Core\Config\Config;
use Forge\Core\Config\Environment;

// Using helper functions (recommended)
$dbHost = env('DB_HOST', 'localhost');
$debug = env('APP_DEBUG', false);
$appName = config('app.name', 'Forge App');

// Using Config class directly
$config = Config::get('database.connections.mysql');
Config::set('cache.driver', 'redis');

// Using Environment class directly  
$env = Environment::getInstance();
$port = $env->get('APP_PORT', 8000);
$isDev = $env->isDevelopment();
$debugEnabled = $env->isDebugEnabled();

// Checking if configuration exists
if (config('services.stripe.key')) {
    // Stripe is configured
}</code></pre>
                    </div>
                </section>

                <section id="async-processing">
                    <h2>Asynchronous Processing & Queues</h2>
                    <p>
                        Understanding when and why to use queues, workers, and asynchronous processing.
                    </p>

                    <h3>The Cashier & Warehouse Analogy</h3>
                    <p>
                        Imagine a store with a cashier taking orders. Most orders are simple — "I want a sheet of paper" — and the cashier handles them quickly because the paper is right next to them. Everyone in line moves smoothly, no one notices any slowdown.
                    </p>
                    <p>
                        But sometimes, someone needs something from the warehouse — like a screw that's 3 feet away. Now the cashier has to walk, pick up the screw, come back, and deliver both items. The person behind has to wait. This is called <strong>latency</strong> — the delay caused by the slower operation.
                    </p>
                    <p>
                        If it's just one person, nothing bad happens. But what if 4 people in a row each need something from the warehouse? Or what if someone needs 2 shovels from deep in the warehouse, and the cashier doesn't know where they are? Now the whole process stops for everyone.
                    </p>

                    <h3>The Solution: Workers</h3>
                    <p>
                        To solve this, you hire a warehouse worker. The cashier handles simple orders (synchronous — fast). The warehouse worker handles complex orders (asynchronous — doesn't block the cashier). When an order needs something from the warehouse, the cashier writes it down and puts it in a queue. The warehouse worker picks up multiple orders at once (batch processing), goes to the warehouse, brings back all the items, and delivers them.
                    </p>
                    <p>
                        If you need more capacity, you hire more workers. You can plan ahead — before a big sale or holiday, you allocate more workers a few hours before the rush. Everything feels smooth.
                    </p>

                    <h3>In Your Application</h3>
                    <p>
                        <strong>Synchronous (Cashier):</strong> Simple operations that are fast — rendering a view, returning JSON, simple database queries. These happen immediately and don't need queues.
                    </p>
                    <p>
                        <strong>Asynchronous (Warehouse Worker):</strong> Complex operations that take time — sending emails, processing images, generating reports, calling external APIs. These go into a queue and are processed by workers.
                    </p>
                    <p>
                        <strong>Batch Processing:</strong> Workers can process multiple jobs at once, like the warehouse worker bringing back multiple items in one trip.
                    </p>
                    <p>
                        <strong>Scaling:</strong> Add more workers before peak times (holidays, promotions, scheduled events) to handle increased load smoothly.
                    </p>

                    <p>
                        <strong>Key Takeaway:</strong> Not every task needs to go to a queue or be processed by a worker. Use queues for operations that would block or slow down your main application flow. Keep simple operations synchronous.
                    </p>
                </section>

                <section id="cli-kernel">
                    <h2>CLI Kernel</h2>
                    <p>
                        Create custom commands and automate tasks.
                    </p>

                    <h3>Creating Custom Commands</h3>
                    <div class="code-block">
                        <pre><code>&lt;?php

declare(strict_types=1);

namespace App\Modules\MyModule\Commands;

use Forge\CLI\Command;
use Forge\Core\Module\Attributes\CLICommand;

#[CLICommand(name: 'app:send-emails', description: 'Send pending emails to users')]
class SendEmailsCommand extends Command
{
    public function execute(array $args): int
    {
        $user = $this->argument('name', $args) ?? 'all users';
        $useQueue = $this->option('queue', $args) !== null;
        
        $this->info('Starting email sending process...');
        
        if ($user !== 'all users') {
            $this->line("Sending emails to user: {$user}");
        } else {
            $this->line('Sending emails to all users');
        }
        
        if ($useQueue) {
            $this->line('Using queue for processing');
        }
        
        // Your email sending logic here
        
        $this->info('Emails sent successfully!');
        
        return 0;
    }
}</code></pre>
                    </div>

                    <p>
                        Commands auto-discover. Just create and use.
                    </p>
                </section>
            </article>
        </main>
    </div>

    <script src="assets/js/docs.js"></script>
</body>
</html>
