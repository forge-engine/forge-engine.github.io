<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Core Concepts - Forge Kernel Documentation</title>
    <link rel="stylesheet" href="assets/css/forge-docs.css">
</head>
<body>
    <div class="docs-container">
        <aside class="sidebar">
            <nav>
                <ul class="sidebar-nav">
                    <li class="sidebar-nav-group">
                        <div class="sidebar-nav-group-title">Navigation</div>
                        <ul class="sidebar-nav" style="list-style: none; padding-left: 0;">
                            <li class="sidebar-nav-item">
                                <a href="index.html" class="sidebar-nav-link">Home</a>
                            </li>
                            <li class="sidebar-nav-item">
                                <a href="introduction.html" class="sidebar-nav-link">Introduction</a>
                            </li>
                            <li class="sidebar-nav-item">
                                <a href="getting-started.html" class="sidebar-nav-link">Getting Started</a>
                            </li>
                            <li class="sidebar-nav-item">
                                <a href="core-concepts.html" class="sidebar-nav-link active">Core Concepts</a>
                            </li>
                            <li class="sidebar-nav-item">
                                <a href="modules.html" class="sidebar-nav-link">Capabilities</a>
                            </li>
                            <li class="sidebar-nav-item">
                                <a href="api-reference.html" class="sidebar-nav-link">API Reference</a>
                            </li>
                        </ul>
                    </li>
                    <li class="sidebar-nav-group">
                        <div class="sidebar-nav-group-title">On This Page</div>
                        <ul class="sidebar-nav" style="list-style: none; padding-left: 0;">
                            <li class="sidebar-nav-item">
                                <a href="#architecture" class="sidebar-nav-link">Architecture</a>
                            </li>
                            <li class="sidebar-nav-item">
                                <a href="#dependency-injection" class="sidebar-nav-link">Dependency Injection</a>
                            </li>
                            <li class="sidebar-nav-item">
                                <a href="#routing-system" class="sidebar-nav-link">Routing System</a>
                            </li>
                            <li class="sidebar-nav-item">
                                <a href="#middleware" class="sidebar-nav-link">Middleware</a>
                            </li>
                            <li class="sidebar-nav-item">
                                <a href="#view-engine" class="sidebar-nav-link">View Engine</a>
                            </li>
                            <li class="sidebar-nav-item">
                                <a href="#database-orm" class="sidebar-nav-link">Database & ORM</a>
                            </li>
                            <li class="sidebar-nav-item">
                                <a href="#capability-system" class="sidebar-nav-link">Capability System</a>
                            </li>
                            <li class="sidebar-nav-item">
                                <a href="#configuration" class="sidebar-nav-link">Configuration</a>
                            </li>
                            <li class="sidebar-nav-item">
                                <a href="#async-processing" class="sidebar-nav-link">Async Processing</a>
                            </li>
                            <li class="sidebar-nav-item">
                                <a href="#cli-kernel" class="sidebar-nav-link">CLI Kernel</a>
                            </li>
                        </ul>
                    </li>
                </ul>
            </nav>
        </aside>

        <button class="mobile-menu-toggle" aria-label="Toggle menu">☰</button>
        <div class="mobile-overlay"></div>

        <main class="main-content">
            <article>
                <header class="docs-header">
                    <h1>Core Concepts</h1>
                    <p>How Forge Kernel works under the hood.</p>
                </header>

                <section id="architecture">
                    <h2>Architecture</h2>
                    <p>
                        Forge Kernel uses a modular architecture with dependency injection. It's built to be simple and flexible. Think of it like a foundation with utilities — you get the foundation, plumbing, electrical, and basic structure. You decide what to build on top.
                    </p>

                    <h3>Kernel Components (Built-in)</h3>
                    <ul>
                        <li>Kernel Core</li>
                        <li>Router</li>
                        <li>View Engine</li>
                        <li>DI Container</li>
                        <li>Capability Loader</li>
                        <li>CLI Kernel</li>
                        <li>Bootstrap</li>
                        <li>Config Manager</li>
                    </ul>

                    <h3>Capabilities (Pluggable)</h3>
                    <p>
                        These are <strong>not</strong> built into the kernel. Install them as capabilities when needed:
                    </p>
                    <ul>
                        <li>Database (ForgeDatabaseSQL)</li>
                        <li>ORM (ForgeSqlOrm)</li>
                        <li>Authentication (ForgeAuth)</li>
                        <li>Storage (ForgeStorage)</li>
                        <li>And more...</li>
                    </ul>
                </section>

                <section id="dependency-injection">
                    <h2>Dependency Injection</h2>
                    <p>
                        Forge's DI container is like a smart warehouse manager. It knows where everything is stored, gets you what you need when you ask, and manages dependencies automatically. It resolves dependencies using PHP attributes, keeping code testable and clean.
                    </p>

                    <h3>Service Registration</h3>
                    <div class="code-block">
                        <pre><code>&lt;?php

use Forge\Core\DI\Attributes\Service;

#[Service]
class UserService
{
    public function __construct(
        private UserRepository $repository,
        private EmailService $emailService
    ) {}
    
    public function createUser(array $data): User
    {
        $user = $this->repository->create($data);
        $this->emailService->sendWelcomeEmail($user);
        return $user;
    }
}

#[Service(singleton: true)] // Only one instance throughout the application
class CacheService
{
    private array $cache = [];
    
    public function get(string $key): mixed
    {
        return $this->cache[$key] ?? null;
    }
}</code></pre>
                    </div>

                    <h3>Interface Binding</h3>
                    <div class="code-block">
                        <pre><code>&lt;?php

use Forge\Core\DI\Attributes\Bind;

interface PaymentGatewayInterface
{
    public function charge(float $amount): bool;
}

#[Service]
#[Bind(PaymentGatewayInterface::class)]
class StripePaymentGateway implements PaymentGatewayInterface
{
    public function charge(float $amount): bool
    {
        // Stripe implementation
        return true;
    }
}</code></pre>
                    </div>
                </section>

                <section id="routing-system">
                    <h2>Routing System</h2>
                    <p>
                        Attribute-based routing that auto-discovers routes from controllers. No separate route files needed.
                    </p>

                    <div class="code-block">
                        <pre><code>&lt;?php

use Forge\Core\Routing\Route;
use Forge\Core\Http\Request;
use Forge\Core\Http\Response;

class ApiController
{
    #[Route("/api/users")]
    public function listUsers(): Response
    {
        return $this->json(User::query()->get());
    }
    
    #[Route("/api/users/{id}", method: "GET")]
    public function getUser(Request $request, int $id): Response
    {
        $user = User::query()->id($id)->first();
        return $this->json($user);
    }
    
    #[Route("/api/users", method: "POST")]
    public function createUser(Request $request): Response
    {
        $data = $request->json();
        $user = User::create($data);
        return $this->json($user, 201);
    }
    
    #[Route("/api/users/{id}", method: "PUT")]
    public function updateUser(Request $request, int $id): Response
    {
        $user = User::query()->id($id)->first();
        $user->update($request->json());
        return $this->json($user);
    }
}</code></pre>
                    </div>

                    <p>
                        <strong>Note:</strong> Use curly braces for route parameters. Names must match method params.
                    </p>
                </section>

                <section id="middleware">
                    <h2>Middleware</h2>
                    <p>
                        Filter HTTP requests before they hit your application.
                    </p>

                    <h3>Creating Middleware</h3>
                    <div class="code-block">
                        <pre><code>&lt;?php

use Forge\Core\Http\Middleware;
use Forge\Core\Http\Request;
use Forge\Core\Http\Response;

class AuthMiddleware extends Middleware
{
    public function handle(Request $request, callable $next): Response
    {
        if (!$request->hasHeader('Authorization')) {
            return new Response('Unauthorized', 401);
        }
        
        // Continue to next middleware or controller
        return $next($request);
    }
}</code></pre>
                    </div>

                    <h3>Applying Middleware</h3>
                    <div class="code-block">
                        <pre><code>&lt;?php

use Forge\Core\Http\Attributes\Middleware;

// Apply middleware to entire controller
#[Middleware("auth")]
class DashboardController
{
    #[Route("/dashboard")]
    public function index(): Response
    {
        return $this->view('dashboard/index');
    }
    
    #[Route("/dashboard/settings")]
    public function settings(): Response
    {
        return $this->view('dashboard/settings');
    }
}

// Apply middleware to specific methods
class UserController
{
    #[Middleware("App\Modules\ForgeAuth\Middlewares\AuthMiddleware")]
    #[Route("/profile")]
    public function profile(): Response
    {
        return $this->view('user/profile');
    }
    
    // Multiple middleware using repeatable attribute
    #[Middleware("web")]
    #[Middleware("auth")]
    #[Route("/admin")]
    public function admin(): Response
    {
        return $this->view('admin/dashboard');
    }
}</code></pre>
                    </div>

                    <p>
                        Use <code>#[Middleware]</code> for controllers/methods, or <code>middlewares</code> in <code>#[Route]</code> for routes.
                    </p>
                </section>

                <section id="view-engine">
                    <h2>View Engine</h2>
                    <p>
                        PHP-first templating. No new syntax to learn.
                    </p>

                    <h3>Template Inheritance</h3>
                    <div class="code-block">
                        <pre><code>&lt;!-- layouts/app.php --&gt;
&lt;!DOCTYPE html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;title&gt;&lt;?= $title ?? 'My App' ?&gt;&lt;/title&gt;
    &lt;?php use Forge\Core\View\View; echo View::section('head'); ?&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;header&gt;
        &lt;?php use Forge\Core\View\View; echo View::section('header'); ?&gt;
    &lt;/header&gt;
    
    &lt;main&gt;
        &lt;?php use Forge\Core\View\View; echo View::section('content'); ?&gt;
    &lt;/main&gt;
    
    &lt;footer&gt;
        &lt;?php use Forge\Core\View\View; echo View::section('footer'); ?&gt;
    &lt;/footer&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
                    </div>

                    <h3>Child Templates</h3>
                    <div class="code-block">
                        <pre><code>&lt;!-- pages/home.php --&gt;
&lt;?php use Forge\Core\View\View; View::layout(name: "layouts/app", loadFromModule: false); ?&gt;

&lt;?php View::startSection('head'); ?&gt;
    &lt;link rel="stylesheet" href="/css/home.css"&gt;
&lt;?php View::endSection(); ?&gt;

&lt;?php View::startSection('content'); ?&gt;
    &lt;div class="hero"&gt;
        &lt;h1&gt;Welcome to &lt;?= $appName ?&gt;&lt;/h1&gt;
        &lt;p&gt;&lt;?= $description ?&gt;&lt;/p&gt;
    &lt;/div&gt;
&lt;?php View::endSection(); ?&gt;</code></pre>
                    </div>

                    <h3>Components</h3>
                    <p>
                        Components are reusable UI pieces. Forge provides flexible ways to create components — with or without PHP classes, with or without view files, in app scope or module scope, with or without DTOs. Choose the approach that fits your needs.
                    </p>

                    <h4>Component Locations</h4>
                    <p>
                        Components can be created in two scopes:
                    </p>
                    <ul>
                        <li><strong>App Scope:</strong> <code>app/Components/</code> — Components specific to your application</li>
                        <li><strong>Module Scope:</strong> <code>modules/ModuleName/src/Resources/components/</code> — Components bundled with capabilities</li>
                    </ul>

                    <h4>1. Class-Based Components (With PHP Class)</h4>
                    <p>
                        Class-based components extend <code>BaseComponent</code> and can use DTOs, view files, or return HTML directly.
                    </p>

                    <h5>App Scope Component with DTO</h5>
                    <div class="code-block">
                        <pre><code>&lt;?php
// app/Components/Ui/Alert.php
namespace App\Components\Ui;

use Forge\Core\View\BaseComponent;
use Forge\Core\View\Component;

#[Component(name: 'Ui/Alert', useDto: true)]
final class Alert extends BaseComponent
{
    public function render(): string
    {
        return $this->renderview('ui/alert', $this->props);
    }
}</code></pre>
                    </div>
                    <p>
                        The DTO class (<code>AlertPropsDto</code>) is automatically created and used when <code>useDto: true</code>.
                    </p>

                    <h5>Module Scope Component with DTO</h5>
                    <div class="code-block">
                        <pre><code>&lt;?php
// modules/ForgeUi/src/Resources/components/Ui/Alert.php
namespace App\Modules\ForgeUi\Resources\Components\Ui;

use Forge\Core\View\BaseComponent;
use Forge\Core\View\Component;

#[Component(name: "ForgeUi:Ui/Alert", useDto: true)]
final class Alert extends BaseComponent
{
    public function render(): string
    {
        return $this->renderview(
            viewPath: "ui/alert",
            data: $this->props,
            loadFromModule: true
        );
    }
}</code></pre>
                    </div>
                    <p>
                        Module components use the <code>ModuleName:Path</code> syntax and set <code>loadFromModule: true</code> when rendering views.
                    </p>

                    <h5>Component Without DTO (Direct Props)</h5>
                    <div class="code-block">
                        <pre><code>&lt;?php
// app/Components/Ui/Button.php
namespace App\Components\Ui;

use Forge\Core\View\BaseComponent;
use Forge\Core\View\Component;

#[Component(name: 'Ui/Button')]
final class Button extends BaseComponent
{
    public function __construct(
        public string $text = '',
        public string $type = 'button'
    ) {}
    
    public function render(): string
    {
        return $this->renderview('ui/button', [
            'text' => $this->text,
            'type' => $this->type
        ]);
    }
}</code></pre>
                    </div>

                    <h5>Component Returning HTML Directly (No View File)</h5>
                    <div class="code-block">
                        <pre><code>&lt;?php
// app/Components/Ui/Badge.php
namespace App\Components\Ui;

use Forge\Core\View\BaseComponent;
use Forge\Core\View\Component;

#[Component(name: 'Ui/Badge')]
final class Badge extends BaseComponent
{
    public function __construct(
        public string $text = '',
        public string $color = 'blue'
    ) {}
    
    public function render(): string
    {
        return raw(
            '&lt;span class="badge badge-' . 
            htmlspecialchars($this->color) . 
            '"&gt;' . 
            htmlspecialchars($this->text) . 
            '&lt;/span&gt;'
        );
    }
}</code></pre>
                    </div>
                    <p>
                        Use the <code>raw()</code> helper when returning HTML directly without a view file.
                    </p>

                    <h4>2. View-Only Components (Without PHP Class)</h4>
                    <p>
                        For simple presentational components, create only a view file. No PHP class needed.
                    </p>
                    <p>
                        Create a view file at <code>app/resources/components/ui/alert.php</code>:
                    </p>
                    <div class="code-block">
                        <pre><code>&lt;!-- app/resources/components/ui/alert.php --&gt;
&lt;div class="alert alert-&lt;?= $type ?? 'info' ?&gt;"&gt;
    &lt;?= htmlspecialchars($message ?? '') ?&gt;
&lt;/div&gt;</code></pre>
                    </div>
                    <p>
                        For module-scoped view components, place them in <code>modules/ModuleName/src/Resources/views/components/</code>.
                    </p>

                    <h4>Using Components</h4>
                    <p>
                        Use the <code>component()</code> helper function to render components:
                    </p>
                    <div class="code-block">
                        <pre><code>&lt;?php
// App scope class-based component
echo component('Ui/Alert', 'class', [
    'type' => 'success',
    'message' => 'User created successfully!'
]);

// Module scope class-based component (auto-detected by ":" syntax)
echo component('ForgeUi:Ui/Alert', 'class', [
    'type' => 'success',
    'children' => 'User created successfully!'
], fromModule: true);

// View-only component (app scope)
echo component('ui/alert', 'view', [
    'type' => 'success',
    'message' => 'User created successfully!'
]);

// View-only component (module scope)
echo component('ui/alert', 'view', [
    'type' => 'success',
    'message' => 'User created successfully!'
], fromModule: true);

// Using Component class directly
use Forge\Core\View\Component;
echo Component::render('Ui/Alert', [
    'type' => 'success',
    'message' => 'User created successfully!'
]);

// Using View class for view-only components
use Forge\Core\View\View;
echo View::viewComponent('ui/alert', [
    'type' => 'success',
    'message' => 'User created successfully!'
]);</code></pre>
                    </div>

                    <h4>Real-World Example</h4>
                    <p>
                        Here's how a module component is used in practice:
                    </p>
                    <div class="code-block">
                        <pre><code>&lt;?php
// modules/ForgeUi/src/Resources/views/components/ui/flash-message.php
use Forge\Core\Helpers\Flash;

$flashMessages = Flash::flat() ?? [];
?&gt;
&lt;?php if (!empty($flashMessages)): ?&gt;
    &lt;div&gt;
        &lt;?php foreach ($flashMessages as $msg): ?&gt;
            &lt;?=
            component(name: "ForgeUi:Ui/Alert", props: [
                "type" => $msg["type"],
                "children" => $msg["message"]
            ], fromModule: true)
            ?&gt;
        &lt;?php endforeach; ?&gt;
    &lt;/div&gt;
&lt;?php endif; ?&gt;</code></pre>
                    </div>

                    <h4>When to Use Each Approach</h4>
                    <ul>
                        <li><strong>Class-based with DTO:</strong> When you want type safety and IDE autocomplete for component props. Best for reusable components with multiple properties.</li>
                        <li><strong>Class-based without DTO:</strong> For simpler components where direct constructor parameters are sufficient.</li>
                        <li><strong>Class-based returning HTML:</strong> For very simple components that don't need a separate view file. Useful for small, self-contained UI elements.</li>
                        <li><strong>View-only components:</strong> Perfect for simple presentational components that just display data. Fastest to create, no PHP class needed.</li>
                        <li><strong>App scope:</strong> Use for application-specific components that won't be shared.</li>
                        <li><strong>Module scope:</strong> Use when creating reusable capability components that can be distributed with your module.</li>
                    </ul>
                </section>

                <section id="database-orm">
                    <h2>Database & ORM (Capabilities)</h2>
                    <p>
                        Database and ORM are <strong>not built into the kernel</strong>. They're capabilities you install when you need them. Install a database capability like <code>ForgeDatabaseSQL</code> or an ORM capability like <code>ForgeSqlOrm</code>.
                    </p>
                    <p>
                        <strong>Note:</strong> The examples below assume you've installed a database/ORM capability. The kernel itself doesn't include these features.
                    </p>

                    <h3>Model Definition</h3>
                    <div class="code-block">
                        <pre><code>&lt;?php

use App\Modules\ForgeSqlOrm\ORM\Model;
use App\Modules\ForgeSqlOrm\ORM\Attributes\Table;
use App\Modules\ForgeSqlOrm\ORM\Attributes\Column;
use App\Modules\ForgeSqlOrm\ORM\Attributes\Hidden;
use App\Modules\ForgeSqlOrm\ORM\Attributes\ProtectedFields;
use App\Modules\ForgeSqlOrm\ORM\Values\Cast;
use App\Modules\ForgeSqlOrm\ORM\Values\Relate;
use App\Modules\ForgeSqlOrm\ORM\Values\RelationKind;

#[Table('users')]
#[ProtectedFields('password', 'remember_token')]
class User extends Model
{
    #[Column(primary: true, cast: Cast::INTEGER)]
    public int $id;
    
    #[Column(cast: Cast::STRING)]
    public string $name;
    
    #[Column(cast: Cast::STRING)]
    public string $email;
    
    #[Column(cast: Cast::STRING)]
    #[Hidden]
    public string $password;
    
    // Relationships use #[Relate] attribute
    #[Relate(
        kind: RelationKind::HasMany,
        target: Post::class,
        foreignKey: 'user_id',
        localKey: 'id'
    )]
    public function posts()
    {
        return $this->relation('posts');
    }
}</code></pre>
                    </div>

                    <h3>Query Builder</h3>
                    <div class="code-block">
                        <pre><code>&lt;?php

// Get all records
$users = User::query()->get();

// Find by ID
$user = User::query()->id(1)->first();

// Where queries
$activeUsers = User::query()
    ->where('status', '=', 'active')
    ->get();

// Advanced queries
$users = User::query()
    ->where('created_at', '>', '2024-01-01')
    ->get();

// With relationships
$user = User::query()
    ->with('posts')
    ->id(1)
    ->first();

// Access relationship
$posts = $user->load('posts');</code></pre>
                    </div>
                    <p>
                        <strong>Note:</strong> Forge uses a query builder pattern. Always start with <code>Model::query()</code> to build queries. There are no static methods like <code>all()</code> or <code>find()</code> directly on the Model class.
                    </p>
                </section>

                <section id="capability-system">
                    <h2>Capability System</h2>
                    <p>
                        Extend Forge Kernel with self-contained capability modules. Think of capabilities like modular additions to a house. The kernel gives you the foundation. Capabilities add what you need: database, ORM, authentication, storage — all optional, all pluggable.
                    </p>
                    <p>
                        Need a database? Install a database capability. Need an ORM? Install an ORM capability. Don't need authentication? Don't install it. The kernel stays lean. You stay in control.
                    </p>

                    <h3>Capability Structure</h3>
                    <div class="code-block">
                        <pre><code>{
  "$schema": "./../../engine/Core/Schema/module-schema.json",
  "name": "forge-my-module",
  "version": "1.0.0",
  "description": "A custom module for my application",
  "type": "generic",
  "order": 100,
  "author": "Your Name",
  "license": "MIT"
}</code></pre>
                    </div>

                    <h3>Capability Class</h3>
                    <div class="code-block">
                        <pre><code>&lt;?php

namespace App\Modules\MyModule;

use Forge\Core\DI\Container;
use Forge\Core\Module\Attributes\Compatibility;
use Forge\Core\Module\Attributes\Module;
use Forge\Core\Module\Attributes\Repository;
use Forge\Core\DI\Attributes\Service;
use Forge\Core\Module\Attributes\LifecycleHook;
use Forge\Core\Module\LifecycleHookName;
use App\Modules\MyModule\Contracts\MyModuleInterface;
use App\Modules\MyModule\Services\MyModuleService;

#[Module(
    name: 'MyModule',
    description: 'A custom module for my application',
    order: 100
)]
#[Service]
#[Compatibility(kernel: '>=0.1.0', php: '>=8.3')]
#[Repository(type: 'git', url: 'https://github.com/your-repo/modules')]
final class MyModule
{
    public function register(Container $container): void
    {
        // Register services
        $container->bind(MyModuleInterface::class, MyModuleService::class);
    }

    #[LifecycleHook(hook: LifecycleHookName::AFTER_MODULE_REGISTER)]
    public function onAfterModuleRegister(): void
    {
        // Boot logic after module registration
    }
}</code></pre>
                    </div>
                </section>

                <section id="configuration">
                    <h2>Configuration Management</h2>
                    <p>
                        Environment-based configuration that's secure and flexible.
                    </p>

                    <div class="code-block">
                        <pre><code>&lt;?php

use Forge\Core\Config\Config;
use Forge\Core\Config\Environment;

// Using helper functions (recommended)
$dbHost = env('DB_HOST', 'localhost');
$debug = env('APP_DEBUG', false);
$appName = config('app.name', 'Forge App');

// Using Config class directly
$config = Config::get('database.connections.mysql');
Config::set('cache.driver', 'redis');

// Using Environment class directly  
$env = Environment::getInstance();
$port = $env->get('APP_PORT', 8000);
$isDev = $env->isDevelopment();
$debugEnabled = $env->isDebugEnabled();

// Checking if configuration exists
if (config('services.stripe.key')) {
    // Stripe is configured
}</code></pre>
                    </div>
                </section>

                <section id="async-processing">
                    <h2>Asynchronous Processing & Queues</h2>
                    <p>
                        Understanding when and why to use queues, workers, and asynchronous processing.
                    </p>

                    <h3>The Cashier & Warehouse Analogy</h3>
                    <p>
                        Imagine a store with a cashier taking orders. Most orders are simple — "I want a sheet of paper" — and the cashier handles them quickly because the paper is right next to them. Everyone in line moves smoothly, no one notices any slowdown.
                    </p>
                    <p>
                        But sometimes, someone needs something from the warehouse — like a screw that's 3 feet away. Now the cashier has to walk, pick up the screw, come back, and deliver both items. The person behind has to wait. This is called <strong>latency</strong> — the delay caused by the slower operation.
                    </p>
                    <p>
                        If it's just one person, nothing bad happens. But what if 4 people in a row each need something from the warehouse? Or what if someone needs 2 shovels from deep in the warehouse, and the cashier doesn't know where they are? Now the whole process stops for everyone.
                    </p>

                    <h3>The Solution: Workers</h3>
                    <p>
                        To solve this, you hire a warehouse worker. The cashier handles simple orders (synchronous — fast). The warehouse worker handles complex orders (asynchronous — doesn't block the cashier). When an order needs something from the warehouse, the cashier writes it down and puts it in a queue. The warehouse worker picks up multiple orders at once (batch processing), goes to the warehouse, brings back all the items, and delivers them.
                    </p>
                    <p>
                        If you need more capacity, you hire more workers. You can plan ahead — before a big sale or holiday, you allocate more workers a few hours before the rush. Everything feels smooth.
                    </p>

                    <h3>In Your Application</h3>
                    <p>
                        <strong>Synchronous (Cashier):</strong> Simple operations that are fast — rendering a view, returning JSON, simple database queries. These happen immediately and don't need queues.
                    </p>
                    <p>
                        <strong>Asynchronous (Warehouse Worker):</strong> Complex operations that take time — sending emails, processing images, generating reports, calling external APIs. These go into a queue and are processed by workers.
                    </p>
                    <p>
                        <strong>Batch Processing:</strong> Workers can process multiple jobs at once, like the warehouse worker bringing back multiple items in one trip.
                    </p>
                    <p>
                        <strong>Scaling:</strong> Add more workers before peak times (holidays, promotions, scheduled events) to handle increased load smoothly.
                    </p>

                    <p>
                        <strong>Key Takeaway:</strong> Not every task needs to go to a queue or be processed by a worker. Use queues for operations that would block or slow down your main application flow. Keep simple operations synchronous.
                    </p>
                </section>

                <section id="cli-kernel">
                    <h2>CLI Kernel</h2>
                    <p>
                        Create custom commands and automate tasks.
                    </p>

                    <h3>Creating Custom Commands</h3>
                    <div class="code-block">
                        <pre><code>&lt;?php

declare(strict_types=1);

namespace App\Modules\MyModule\Commands;

use Forge\CLI\Command;
use Forge\Core\Module\Attributes\CLICommand;

#[CLICommand(name: 'app:send-emails', description: 'Send pending emails to users')]
class SendEmailsCommand extends Command
{
    public function execute(array $args): int
    {
        $user = $this->argument('name', $args) ?? 'all users';
        $useQueue = $this->option('queue', $args) !== null;
        
        $this->info('Starting email sending process...');
        
        if ($user !== 'all users') {
            $this->line("Sending emails to user: {$user}");
        } else {
            $this->line('Sending emails to all users');
        }
        
        if ($useQueue) {
            $this->line('Using queue for processing');
        }
        
        // Your email sending logic here
        
        $this->info('Emails sent successfully!');
        
        return 0;
    }
}</code></pre>
                    </div>

                    <p>
                        Commands auto-discover. Just create and use.
                    </p>
                </section>
            </article>
        </main>
    </div>

    <script src="assets/js/docs.js"></script>
</body>
</html>
